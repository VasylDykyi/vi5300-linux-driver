From f81b4a33b9f54934a28b488aebbb028517c69e26 Mon Sep 17 00:00:00 2001
From: Vasyl Dykyi <wasya606@gmail.com>
Date: Sat, 31 May 2025 17:45:42 +0300
Subject: [PATCH] Porting and integrate the dToF sensor vi5300 driver for
 6.15.0

---
 arch/arm/boot/dts/overlays/Makefile           |    1 +
 arch/arm/boot/dts/overlays/vi5300-overlay.dts |   26 +
 drivers/misc/Kconfig                          |    1 +
 drivers/misc/Makefile                         |    2 +
 drivers/misc/vi5300/Kconfig                   |    9 +
 drivers/misc/vi5300/Makefile                  |    7 +
 drivers/misc/vi5300/vi5300.h                  |  151 ++
 drivers/misc/vi5300/vi5300_api.c              |  807 ++++++++++
 drivers/misc/vi5300/vi5300_api.h              |   40 +
 drivers/misc/vi5300/vi5300_def.h              |   37 +
 drivers/misc/vi5300/vi5300_firmware.c         |   48 +
 drivers/misc/vi5300/vi5300_firmware.h         |   25 +
 drivers/misc/vi5300/vi5300_module.c           | 1328 +++++++++++++++++
 drivers/misc/vi5300/vi5300_platform.c         |  113 ++
 drivers/misc/vi5300/vi5300_platform.h         |   30 +
 15 files changed, 2625 insertions(+)
 create mode 100644 arch/arm/boot/dts/overlays/vi5300-overlay.dts
 create mode 100644 drivers/misc/vi5300/Kconfig
 create mode 100644 drivers/misc/vi5300/Makefile
 create mode 100644 drivers/misc/vi5300/vi5300.h
 create mode 100644 drivers/misc/vi5300/vi5300_api.c
 create mode 100644 drivers/misc/vi5300/vi5300_api.h
 create mode 100644 drivers/misc/vi5300/vi5300_def.h
 create mode 100644 drivers/misc/vi5300/vi5300_firmware.c
 create mode 100644 drivers/misc/vi5300/vi5300_firmware.h
 create mode 100644 drivers/misc/vi5300/vi5300_module.c
 create mode 100644 drivers/misc/vi5300/vi5300_platform.c
 create mode 100644 drivers/misc/vi5300/vi5300_platform.h

diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index d784e8b41b57..281149574378 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -341,6 +341,7 @@ dtbo-$(CONFIG_ARCH_BCM2835) += \
 	vc4-kms-v3d-pi5.dtbo \
 	vc4-kms-vga666.dtbo \
 	vga666.dtbo \
+	vi5300.dtbo \
 	vl805.dtbo \
 	w1-gpio.dtbo \
 	w1-gpio-pi5.dtbo \
diff --git a/arch/arm/boot/dts/overlays/vi5300-overlay.dts b/arch/arm/boot/dts/overlays/vi5300-overlay.dts
new file mode 100644
index 000000000000..7a8a241cdaac
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/vi5300-overlay.dts
@@ -0,0 +1,26 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include "i2c-buses.dtsi"
+
+/ {
+	compatible = "brcm,bcm2835";
+
+	fragment@0 {
+		target = <&i2c1>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;           
+			status = "okay";
+
+			vi5300: vi5300@6c {
+				status = "okay";
+				compatible = "evisionics,vi5300";
+				reg = <0x6c>;
+				irq-gpios = <&gpio 24 GPIO_ACTIVE_LOW>;
+				xshut-gpios = <&gpio 23 GPIO_ACTIVE_LOW>;
+			};
+		};
+	};
+};
\ No newline at end of file
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index f7a557e7a01b..47a55763f217 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -674,4 +674,5 @@ source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/mchp_pci1xxxx/Kconfig"
 source "drivers/misc/keba/Kconfig"
+source "drivers/misc/vi5300/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 2fb8d9c9a284..e83d9f56b70f 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -77,3 +77,5 @@ lan966x-pci-objs		:= lan966x_pci.o
 lan966x-pci-objs		+= lan966x_pci.dtbo.o
 obj-$(CONFIG_MCHP_LAN966X_PCI)	+= lan966x-pci.o
 obj-y				+= keba/
+obj-y               		+= vi5300/
+
diff --git a/drivers/misc/vi5300/Kconfig b/drivers/misc/vi5300/Kconfig
new file mode 100644
index 000000000000..e43251fd293a
--- /dev/null
+++ b/drivers/misc/vi5300/Kconfig
@@ -0,0 +1,9 @@
+
+config VI5300
+	tristate "VI5300 I2C DEVICE"
+	depends on I2C && SYSFS
+	help
+	  This driver provides support for VI5300 - direct Time-of-Flight (dToF) sensor 
+	  module within a single modular package which integrates a single photon
+	  avalanche diode (SPAD) sensor and a VCSEL emitter.
+
diff --git a/drivers/misc/vi5300/Makefile b/drivers/misc/vi5300/Makefile
new file mode 100644
index 000000000000..541a7a2533ff
--- /dev/null
+++ b/drivers/misc/vi5300/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the vi5300 drivers.
+#
+ccflags-y				+= -Idrivers/misc/vi5300
+
+obj-$(CONFIG_VI5300)	+= vi5300.o
+vi5300-y                += vi5300_module.o vi5300_platform.o vi5300_api.o vi5300_firmware.o
diff --git a/drivers/misc/vi5300/vi5300.h b/drivers/misc/vi5300/vi5300.h
new file mode 100644
index 000000000000..12ed45b51f04
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300.h
@@ -0,0 +1,151 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#ifndef VI5300_H
+#define VI5300_H
+
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+#include "vi5300_def.h"
+
+#define VI5300_CHIP_ADDR 0xD8
+
+#define VI5300_REG_MCU_CFG 0x00
+#define VI5300_REG_SYS_CFG 0x01
+#define VI5300_REG_DEV_STAT 0x02
+#define VI5300_REG_INTR_STAT 0x03
+#define VI5300_REG_INTR_MASK 0x04
+#define VI5300_REG_I2C_IDLE_TIME 0x05
+#define VI5300_REG_DEV_ADDR 0x06
+#define VI5300_REG_PW_CTRL 0x07
+#define VI5300_REG_SPCIAL_PURP 0x08
+#define VI5300_REG_CMD 0x0A
+#define VI5300_REG_SIZE 0x0B
+#define VI5300_REG_SCRATCH_PAD_BASE 0x0C
+#define VI5300_REG_CHIPID_BASE 0x2C
+#define VI5300_REG_RCO_AO 0x37
+#define VI5300_REG_DIGLDO_VREF 0x38
+#define VI5300_REG_PLLLDO_VREF 0x39
+#define VI5300_REG_ANALDO_VREF 0x3A
+#define VI5300_REG_PD_RESET 0x3B
+#define VI5300_REG_I2C_STOP_DELAY 0x3C
+#define VI5300_REG_TRIM_MODE 0x3D
+#define VI5300_REG_GPIO_SINGLE 0x3E
+#define VI5300_REG_ANA_TEST_SINGLE 0x3F
+
+#define VI5300_WRITEFW_CMD 0x03
+#define VI5300_USER_CFG_CMD 0x09
+#define VI5300_XTALK_TRIM_CMD 0x0D
+#define VI5300_SINGLE_RANGE_CMD 0x0E
+#define VI5300_CONTINOUS_RANGE_CMD 0x0F
+#define VI5300_STOP_RANGE_CMD 0x01F
+
+#define VI5300_OTPW_SUBCMD 0x02
+#define VI5300_OTPR_SUBCMD 0x03
+#define VI5300_MAX_WAIT_RETRY 5
+#define DEFAULT_INTEGRAL_COUNTS 131072
+#define DEFAULT_FRAME_COUNTS 30
+
+#define VI5300_ERROR_NONE ((VI5300_Error) 0)
+#define VI5300_ERROR_CPU_BUSY ((VI5300_Error) -1)
+#define VI5300_ERROR_ENABLE_INTR ((VI5300_Error) -2)
+#define VI5300_ERROR_XTALK_CALIB ((VI5300_Error) -3)
+#define VI5300_ERROR_OFFSET_CALIB ((VI5300_Error) -4)
+#define VI5300_ERROR_XTALK_CONFIG ((VI5300_Error) -5)
+#define VI5300_ERROR_SINGLE_CMD ((VI5300_Error) -6)
+#define VI5300_ERROR_CONTINUOUS_CMD ((VI5300_Error) -7)
+#define VI5300_ERROR_GET_DATA ((VI5300_Error) -8)
+#define VI5300_ERROR_STOP_CMD ((VI5300_Error) -9)
+#define VI5300_ERROR_IRQ_STATE ((VI5300_Error) -10)
+#define VI5300_ERROR_FW_FAILURE ((VI5300_Error) -11)
+#define VI5300_ERROR_POWER_ON ((VI5300_Error) -12)
+#define VI5300_ERROR_POWER_OFF ((VI5300_Error) -13)
+#define VI5300_ERROR_OTP_SIZE ((VI5300_Error) -14)
+#define VI5300_ERROR_REFTOF_CONFIG ((VI5300_Error) -15)
+
+struct VI5300_Measurement_Data {
+	int16_t RangeTof;
+	uint32_t timeUSec;
+	uint32_t RangeNoise;
+	uint32_t RangePeak;
+	uint32_t RangeConfidence;
+	uint8_t RangeStatus;
+	uint16_t RangeCGcount;
+	uint32_t RangeIntegralTimes;
+};
+
+struct VI5300_XTALK_Calib_Data {
+	int8_t xtalk_cal;
+	uint16_t xtalk_peak;
+	uint8_t xtalk_maxratio;
+};
+
+struct VI5300_OFFSET_Calib_Data {
+	int16_t offset_cal;
+	int16_t ref_tof;
+};
+
+struct VI5300_XTALK_Config_Data {
+	int8_t xtalk_config;
+	uint8_t maxratio;
+};
+
+struct vi5300_data {
+ 	struct device *dev;
+ 	const char *dev_name;
+	struct VI5300_Measurement_Data Rangedata;
+	struct VI5300_XTALK_Calib_Data XtalkData;
+	struct VI5300_OFFSET_Calib_Data OffsetData;
+	struct VI5300_XTALK_Config_Data XtalkConfig;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct miscdevice miscdev;
+	struct timespec64 start_ts;
+	int irq_gpio;
+	int xshut_gpio;
+	int irq;
+	uint32_t chip_enable;
+	uint32_t enable_debug;
+	uint8_t intr_state;
+	uint8_t fwdl_status;
+	int16_t offset_config;
+	int16_t reftof_config;
+	uint32_t period;
+	struct mutex work_mutex;
+};
+
+union inte_data {
+	uint32_t intecnts;
+	uint8_t buf[4];
+};
+
+enum VI5300_INT_STATUS {
+	VI5300_INTR_DISABLED = 0,
+	VI5300_INTR_ENABLED,
+};
+
+#define vi5300_infomsg(str, args...) \
+	 pr_info("%s: " str, __func__, ##args)
+#define vi5300_dbgmsg(str, args...) \
+	 pr_debug("%s: " str, __func__, ##args)
+#define vi5300_errmsg(str, args...) \
+	 pr_err("%s: " str, __func__, ##args)
+
+#endif
diff --git a/drivers/misc/vi5300/vi5300_api.c b/drivers/misc/vi5300/vi5300_api.c
new file mode 100644
index 000000000000..9de4bd100225
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_api.c
@@ -0,0 +1,807 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+
+#include "vi5300.h"
+#include "vi5300_platform.h"
+#include "vi5300_firmware.h"
+#include "vi5300_api.h"
+
+#define PILEUP_A (9231000)
+#define PILEUP_B (4896)
+#define PILEUP_C (1922)
+#define PILEUP_D (10)
+
+#define STATUS_TOF_CONFIDENT 0
+#define STATUS_TOF_SEMI_CONFIDENT 6
+#define STATUS_TOF_NOT_CONFIDENT 7
+#define STATUS_TOF_NO_OBJECT 255
+
+VI5300_Error VI5300_Chip_PowerON(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = gpio_direction_output(dev->xshut_gpio, 0);
+	mdelay(5);
+	Status = gpio_direction_output(dev->xshut_gpio, 1);
+	mdelay(5);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Chip Power ON Failed Status = %d\n", Status);
+		return VI5300_ERROR_POWER_ON;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Chip_PowerOFF(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = gpio_direction_output(dev->xshut_gpio, 0);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Chip Power OFF Failed Status = %d\n", Status);
+		return VI5300_ERROR_POWER_OFF;
+	}
+
+	return Status;
+}
+
+void VI5300_Chip_Register_Init(VI5300_DEV dev)
+{
+	vi5300_write_byte(dev, VI5300_REG_MCU_CFG, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_SYS_CFG, 0x0C);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x01);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_INTR_MASK, 0x21);
+	vi5300_write_byte(dev, VI5300_REG_I2C_IDLE_TIME, 0x0E);
+	vi5300_write_byte(dev, VI5300_REG_SPCIAL_PURP, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_RCO_AO, 0x80);
+	vi5300_write_byte(dev, VI5300_REG_DIGLDO_VREF, 0x30);
+	vi5300_write_byte(dev, VI5300_REG_PLLLDO_VREF, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_ANALDO_VREF, 0x30);
+	vi5300_write_byte(dev, VI5300_REG_PD_RESET, 0x80);
+	vi5300_write_byte(dev, VI5300_REG_I2C_STOP_DELAY, 0x80);
+	vi5300_write_byte(dev, VI5300_REG_TRIM_MODE, 0x80);
+	vi5300_write_byte(dev, VI5300_REG_GPIO_SINGLE, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_ANA_TEST_SINGLE, 0x00);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x0E);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x0F);
+}
+
+static void VI5300_Waiting_For_RCO_Stable(VI5300_DEV dev)
+{
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x0F);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x0E);
+	mdelay(4);
+}
+
+VI5300_Error VI5300_Wait_For_CPU_Ready(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	uint8_t stat;
+	int retry = 0;
+
+	do {
+		mdelay(1);
+		vi5300_read_byte(dev, VI5300_REG_DEV_STAT, &stat);
+	}while((retry++ < VI5300_MAX_WAIT_RETRY)
+		&&(stat & 0x01));
+	if(retry >= VI5300_MAX_WAIT_RETRY)
+	{
+		vi5300_errmsg("CPU Busy stat = %d\n", stat);
+		return VI5300_ERROR_CPU_BUSY;
+	}
+
+	return Status;
+}
+
+void VI5300_Read_ChipVersion(VI5300_DEV dev)
+{
+	uint8_t chipid[3] = {0};
+	uint32_t ChipVersion = 0;
+
+	vi5300_read_multibytes(dev, VI5300_REG_CHIPID_BASE, chipid, 3);
+	ChipVersion = (chipid[1] << 16) + (chipid[0] << 8) + chipid[2];
+	vi5300_errmsg("VI5300 ChipVersion: 0x%x\n", ChipVersion);
+}
+
+VI5300_Error VI5300_Init_FirmWare(VI5300_DEV dev)
+{
+	uint8_t  sys_cfg_data = 0;
+	uint16_t fw_size = 0;
+	uint16_t fw_send = 0;
+	uint8_t val;
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	fw_size = LoadFirmware(dev);
+	if(!fw_size)
+	{
+		vi5300_errmsg("Firmware Load Failed!\n");
+		return VI5300_ERROR_FW_FAILURE;
+	}
+	vi5300_errmsg("Firmware Load begin!!!\n");
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x08);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x0a);
+	vi5300_write_byte(dev, VI5300_REG_MCU_CFG, 0x06);
+	vi5300_read_byte(dev, VI5300_REG_SYS_CFG, &sys_cfg_data);
+	vi5300_write_byte(dev, VI5300_REG_SYS_CFG, sys_cfg_data | (0x01 << 0));
+	vi5300_write_byte(dev, VI5300_REG_CMD, 0x01);
+	vi5300_write_byte(dev, VI5300_REG_SIZE, 0x02);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x0);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x01, 0x0);
+	while(fw_size >= 32)
+	{
+		vi5300_write_reg_offset(dev, VI5300_REG_CMD, 0, VI5300_WRITEFW_CMD);
+		vi5300_write_reg_offset(dev, VI5300_REG_SIZE, 0, 32);
+		vi5300_write_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, Firmware+fw_send * 32, 32);
+		udelay(10);
+		fw_send += 1;
+		fw_size -= 32;
+	}
+	if(fw_size > 0)
+	{
+		vi5300_write_reg_offset(dev, VI5300_REG_CMD, 0, VI5300_WRITEFW_CMD);
+		vi5300_write_reg_offset(dev, VI5300_REG_SIZE, 0, (uint8_t)fw_size);
+		vi5300_write_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, Firmware + fw_send * 32, fw_size);
+	}
+	vi5300_write_byte(dev, VI5300_REG_SYS_CFG, sys_cfg_data & ~(0x01 << 0));
+	vi5300_write_byte(dev, VI5300_REG_MCU_CFG, 0x06);
+	vi5300_write_byte(dev, VI5300_REG_PD_RESET, 0xA0);
+	vi5300_write_byte(dev, VI5300_REG_PD_RESET, 0x80);
+	vi5300_write_byte(dev, VI5300_REG_MCU_CFG, 0x07);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x02);
+	vi5300_write_byte(dev, VI5300_REG_PW_CTRL, 0x00);
+	vi5300_errmsg("Firmware Load end!!!\n");
+	mdelay(5);
+	vi5300_read_byte(dev, VI5300_REG_SPCIAL_PURP, &val);
+	if(val != 0x66)
+	{
+		vi5300_errmsg("Download Firmware Failed, value = %d\n", val);
+		Status = VI5300_ERROR_FW_FAILURE;
+	}
+
+	return Status;
+}
+
+
+static void VI5300_Temperature_Enable(VI5300_DEV dev, uint8_t enable)
+{
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x0e);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 3, enable);
+	mdelay(5);
+}
+
+__attribute__((unused)) static void VI5300_Integral_Counts_Write(VI5300_DEV dev, uint32_t inte_counts)
+{
+	union inte_data {
+		uint32_t intecnts;
+		uint8_t buf[4];
+	} intedata;
+
+	intedata.intecnts = inte_counts;
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x03);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 3, intedata.buf[0]);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 4, intedata.buf[1]);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 5, intedata.buf[2]);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+}
+
+__attribute__((unused)) static void VI5300_Delay_Count_Write(VI5300_DEV dev, uint16_t delay_count)
+{
+	union delay_data {
+		uint16_t delay;
+		uint8_t buf[2];
+	} delaydata;
+
+	delaydata.delay = delay_count;
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x02);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x04);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 3, delaydata.buf[1]);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 4, delaydata.buf[0]);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+}
+
+__attribute__((unused)) static void VI5300_Set_Integralcounts_Frame(VI5300_DEV dev, uint8_t fps, uint32_t intecoutns)
+{
+	uint32_t inte_time = 0;
+	uint32_t fps_time = 0;
+	uint32_t delay_time = 0;
+	uint16_t delay_counts = 0;
+
+	inte_time = intecoutns * 1463 / 10;
+	fps_time = 1000000000 / fps;
+	delay_time = fps_time - inte_time - 1600000;
+	delay_counts = (uint16_t)(delay_time / 40900);
+
+	VI5300_Integral_Counts_Write(dev, intecoutns);
+	VI5300_Delay_Count_Write(dev, delay_counts);
+}
+
+void VI5300_Set_Period(VI5300_DEV dev, uint32_t period)
+{
+	uint32_t inte_time = 0;
+	uint32_t fps_time = 0;
+	uint32_t delay_time = 0;
+	uint16_t delay_counts = 0;
+	union inte_data pdata = {0};
+	union delay_data {
+		uint16_t delay;
+		uint8_t buf[2];
+	} delaydata;
+
+	VI5300_Waiting_For_RCO_Stable(dev);
+	if(period == 0)
+	{
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x00);
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x02);
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x04);
+		vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+		msleep(5);
+		vi5300_read_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, &delaydata.buf[1]);
+		vi5300_read_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, &delaydata.buf[0]);
+	} else {
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x00);
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x03);
+		vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x01);
+		vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+		msleep(5);
+		vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, pdata.buf, 3);
+		inte_time = pdata.intecnts * 1463 / 10;
+		fps_time = 1000000000 / period;
+		delay_time = fps_time - inte_time - 1600000;
+		delay_counts = (uint16_t)(delay_time / 40900);
+		delaydata.delay = delay_counts;
+	}
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x02);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x04);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 3, delaydata.buf[1]);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 4, delaydata.buf[0]);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	msleep(5);
+}
+
+VI5300_Error VI5300_Read_OTP(VI5300_DEV dev, uint8_t base, uint8_t size, uint8_t* out)
+{
+	if(size > 32)
+		return VI5300_ERROR_OTP_SIZE;
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x03);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x01, size);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x02, base);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+	vi5300_read_multibytes(dev, 0x0F, out, size);
+	return 0;
+}
+
+__attribute__((unused)) static uint8_t VI5300_Get_MA_Window_Data(VI5300_DEV dev)
+{
+	uint8_t sum_ma = 0;
+	int i = 0;
+	uint8_t ma_val[8];
+
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x00, 0x00);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x01, 0x08);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x02, 0x06);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+
+	msleep(5);
+	vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, ma_val, 8);
+	for(i = 0; i < 8; i++)
+	{
+		sum_ma += ((ma_val[i] & 0x0F)+((ma_val[i] >> 4) & 0x0F));
+	}
+	return sum_ma;
+}
+
+static uint32_t VI5300_Calculate_Pileup_Bias(VI5300_DEV dev, uint32_t peak, uint32_t noise, uint32_t intetimes)
+{
+	uint32_t xth[] = {0,8,20,44,79,117};
+	uint32_t pth[] = {0,0,7,26,52,79};
+	uint8_t i = 0;
+	uint8_t bias = 0;
+	uint32_t peak_tmp = 0;
+
+	if(intetimes == 0)
+	{
+		return bias;
+	}
+
+	peak_tmp = (peak - noise * 3 / 8) * 16 / intetimes;
+	for(i = 0;i < ARRAY_SIZE(xth) - 1;i++)
+	{
+		if(peak_tmp < xth[i+1])
+		{
+			bias = (pth[ i + 1 ] - pth[i]) * ( peak_tmp -xth[i])/(xth[i+1]-xth[i])+ pth[i];
+			break;
+		} else if(peak_tmp >= xth[5])
+		{
+			bias = (pth[5]-pth[4]) * ( peak_tmp - xth[4])/(xth[5]-xth[4])+pth[4];
+			break;
+		}
+	}
+
+	return bias;
+}
+
+static uint32_t VI5300_Calculate_Confidence(VI5300_DEV dev, uint32_t peak, uint32_t noise, uint32_t intetimes)
+{
+	const uint32_t s_noise[10] = {19, 83, 163, 691, 1243, 2539, 5091, 10395, 20427, 33235};
+	const uint32_t s_lower[10] = {16, 25, 45, 145, 258, 501, 1004, 1980, 3804, 6063};
+	const uint32_t s_upper[10] = {26, 35, 61, 173, 303, 574, 1148, 2220, 4230, 6705};
+	uint32_t confidence;
+	uint32_t noise_r;
+	uint32_t peak_r;
+	uint32_t lower, upper;
+	int i = 0;
+
+	if(peak > 8000000)
+		peak_r = peak * 256 / intetimes * 4;
+	else if(peak > 4000000)
+		peak_r = peak * 512 / intetimes * 2;
+	else
+		peak_r = peak * 1024 / intetimes;
+
+	noise_r = noise * 65536 / intetimes * 2;
+
+	for (i = 0; i < ARRAY_SIZE(s_noise) - 1; i++)
+	{
+		if (noise_r < s_noise[i + 1])
+		{
+			lower = (s_lower[i + 1] - s_lower[i]) * abs(noise_r - s_noise[i]) / (s_noise[i + 1] - s_noise[i]) + s_lower[i];
+			upper = (s_upper[i + 1] - s_upper[i]) * abs(noise_r - s_noise[i]) / (s_noise[i + 1] - s_noise[i]) + s_upper[i];
+			break;
+		} else if(noise_r >= s_noise[9]){
+			lower = (s_lower[9] - s_lower[8]) * abs(noise_r - s_noise[8]) / (s_noise[9] - s_noise[8]) + s_lower[8];
+			upper = (s_upper[9] - s_upper[8]) * abs(noise_r - s_noise[8]) / (s_noise[9] - s_noise[8]) + s_upper[8];
+			break;
+		}
+	}
+	if (peak_r < lower) {
+		confidence = 0;
+	} else if (peak_r > upper) {
+		confidence = 100;
+	} else {
+		confidence = 100 * (peak_r - lower) / (upper - lower);
+	}
+
+	return confidence;
+}
+
+VI5300_Error VI5300_Single_Measure(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("CPU Abnormal Single Measure!Status = %d\n", Status);
+		return VI5300_ERROR_SINGLE_CMD;
+	}
+	VI5300_Waiting_For_RCO_Stable(dev);
+	Status = vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_SINGLE_RANGE_CMD);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Single measure Failed Status = %d\n", Status);
+		return VI5300_ERROR_SINGLE_CMD;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Start_Continuous_Measure(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("CPU Abnormal Continuous Measure!Status = %d\n", Status);
+		return VI5300_ERROR_CONTINUOUS_CMD;
+	}
+	VI5300_Waiting_For_RCO_Stable(dev);
+	Status = vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_CONTINOUS_RANGE_CMD);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Continuous Measure Failed Status = %d\n", Status);
+		return VI5300_ERROR_CONTINUOUS_CMD;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Stop_Continuous_Measure(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_STOP_RANGE_CMD);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Stop Measure Failed Status = %d\n", Status);
+		return VI5300_ERROR_STOP_CMD;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Get_Measure_Data(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	uint8_t buf[32];
+	int16_t millimeter = 0;
+	uint16_t xtalkcount = 0;
+	uint32_t noise = 0;
+	uint32_t peak1 = 0;
+	uint32_t peak2 = 0;
+	uint32_t integral_times = 0;
+	uint32_t bias = 0;
+	uint32_t confidence = 0;
+	struct timespec64 end_ts = {0},ts_sub = {0};
+
+	Status |= vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, buf, 32);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Get Range Data Failed Status = %d\n", Status);
+		return VI5300_ERROR_GET_DATA;
+	}
+	millimeter = *((int16_t *)(buf + 12));
+	integral_times = *((uint32_t *)(buf + 22));
+	peak1 = *((uint32_t *)(buf + 28));
+	peak2 = *((uint32_t *)(buf + 8));
+	integral_times = integral_times &0x00ffffff;
+	noise = *((uint32_t *)(buf + 26));
+	noise = noise & 0x0000ffff;
+	xtalkcount = *((uint16_t *)(buf + 14));
+	bias = VI5300_Calculate_Pileup_Bias(dev, peak2, noise, integral_times);
+	confidence = VI5300_Calculate_Confidence(dev, peak1, noise, integral_times);
+	millimeter = millimeter + (int16_t)bias;
+	millimeter = millimeter - dev->offset_config;
+
+	ktime_get_real_ts64(&end_ts);
+	ts_sub = timespec64_sub(end_ts, dev->start_ts);
+	dev->Rangedata.timeUSec = ts_sub.tv_sec * 1000000 + ts_sub.tv_nsec / 1000;
+	dev->Rangedata.RangeTof = millimeter;
+	dev->Rangedata.RangeNoise = noise;
+	dev->Rangedata.RangePeak = peak1;
+	dev->Rangedata.RangeConfidence = confidence;
+	dev->Rangedata.RangeCGcount = xtalkcount;
+	dev->Rangedata.RangeIntegralTimes = integral_times;
+
+	if (confidence >= 70) {
+		dev->Rangedata.RangeStatus = STATUS_TOF_CONFIDENT;
+	} else if (confidence >= 30) {
+		dev->Rangedata.RangeStatus = STATUS_TOF_SEMI_CONFIDENT;
+	} else if (confidence > 0) {
+		dev->Rangedata.RangeStatus = STATUS_TOF_NOT_CONFIDENT;
+	} else {
+		dev->Rangedata.RangeStatus = STATUS_TOF_NO_OBJECT;
+	}
+
+	if(dev->enable_debug)
+	{
+		vi5300_errmsg("timeUSec:%d, RangeTof:%d,  noise:%d, peak1:%d, confidence:%d, integral_times:%d\n",
+					dev->Rangedata.timeUSec,
+					dev->Rangedata.RangeTof,
+					dev->Rangedata.RangeNoise,
+					dev->Rangedata.RangePeak,
+					dev->Rangedata.RangeConfidence,
+					dev->Rangedata.RangeIntegralTimes);
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Get_Interrupt_State(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	uint8_t stat;
+
+	Status = vi5300_read_byte(dev, VI5300_REG_INTR_STAT, &stat);
+	if(!(stat & 0x01))
+	{
+		vi5300_errmsg("Get Interrupt State Failed Status = %d\n", Status);
+		return VI5300_ERROR_IRQ_STATE;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Interrupt_Enable(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	int loop = 0;
+	uint8_t enable = 0;
+
+	do
+	{
+		vi5300_read_byte(dev, VI5300_REG_INTR_MASK, &enable);
+		enable |=  0x01;
+		vi5300_write_byte(dev, VI5300_REG_INTR_MASK, enable);
+		vi5300_read_byte(dev, VI5300_REG_INTR_MASK, &enable);
+		loop++;
+	} while((loop < VI5300_MAX_WAIT_RETRY)
+		&& (!(enable & 0x01)));
+	if(loop >= VI5300_MAX_WAIT_RETRY)
+	{
+		vi5300_errmsg("Enable interrupt Failed Status = %d\n", Status);
+		return VI5300_ERROR_ENABLE_INTR;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Chip_Init(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	VI5300_Read_ChipVersion(dev);
+	VI5300_Chip_Register_Init(dev);
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Internal CPU busy!\n");
+		return Status;
+	}
+	Status = VI5300_Interrupt_Enable(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Clear Interrupt Mask failed!\n");
+		return Status;
+	}
+	Status = VI5300_Init_FirmWare(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Download Firmware Failed!\n");
+		return Status;
+	}
+	VI5300_Read_FW_Version(dev);
+
+	return Status;
+}
+
+VI5300_Error VI5300_Start_XTalk_Calibration(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("CPU Abnormal XTALK Calibrating Status = %d\n", Status);
+		return VI5300_ERROR_XTALK_CALIB;
+	}
+	VI5300_Waiting_For_RCO_Stable(dev);
+	VI5300_Temperature_Enable(dev, 0);
+	Status = vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_XTALK_TRIM_CMD);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("XTALK Calibration Failed Status = %d\n", Status);
+		return VI5300_ERROR_XTALK_CALIB;
+	}
+
+	return Status;
+}
+
+VI5300_Error VI5300_Start_Offset_Calibration(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	uint8_t buf[32];
+	int16_t mm = 0;
+	uint32_t peak1 = 0;
+	uint32_t peak2 = 0;
+	uint32_t inte_t = 0;
+	uint32_t noise = 0;
+	uint32_t bias = 0;
+	int16_t total_r = 0;
+	int16_t total_m = 0;
+	int16_t offset = 0;
+	int16_t ref_tof = 0;
+	int cnt = 0;
+	uint8_t stat = 0;
+
+	Status = vi5300_read_byte(dev, VI5300_REG_INTR_STAT, &stat);
+	VI5300_Temperature_Enable(dev, 0);
+	Status = VI5300_Start_Continuous_Measure(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Offset Calibtration Start Failed!\n");
+		Status = VI5300_ERROR_OFFSET_CALIB;
+		goto err_exit;
+	}
+	while(1)
+	{
+		mdelay(35);
+		Status = vi5300_read_byte(dev, VI5300_REG_INTR_STAT, &stat);
+		if(Status == VI5300_ERROR_NONE)
+		{
+			if((stat & 0x01) == 0x01)
+			{
+				Status |= vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, buf, 16);
+				Status |= vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE + 0x10, buf + 16, 16);
+				if(Status != VI5300_ERROR_NONE)
+				{
+					vi5300_errmsg("Get Range Data Failed Status = %d\n", Status);
+					break;
+				}
+				mm = *((int16_t *)(buf + 12));
+				ref_tof = *((int16_t *)(buf + 20));
+				inte_t = *((uint32_t *)(buf + 22));
+				peak1 = *((uint32_t *)(buf + 28));
+				peak2 = *((uint32_t *)(buf + 8));
+				inte_t = inte_t &0x00ffffff;
+				noise = *((uint32_t *)(buf + 26));
+				noise = noise &0x0000ffff;
+				bias = VI5300_Calculate_Pileup_Bias(dev, peak2, noise, inte_t);
+				mm = mm + (int16_t)bias;
+				total_m += mm;
+				total_r += ref_tof;
+				++cnt;
+			}else
+				continue;
+		} else {
+			vi5300_errmsg("Can't Get irq State!Status = %d\n", Status);
+			break;
+		}
+		if(cnt >= 30)
+			break;
+	}
+	Status = VI5300_Stop_Continuous_Measure(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("Offset Calibtration Stop Failed!\n");
+		Status = VI5300_ERROR_OFFSET_CALIB;
+		goto err_exit;
+	}
+	offset = total_m / 30;
+	dev->OffsetData.offset_cal = offset - 50;
+	dev->OffsetData.ref_tof = total_r / cnt;
+
+err_exit:
+	VI5300_Temperature_Enable(dev, 1);
+	return Status;
+}
+
+
+VI5300_Error VI5300_Get_XTalk_Parameter(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	uint8_t val;
+	uint8_t cg_buf[5];
+
+	Status = vi5300_read_byte(dev, VI5300_REG_SPCIAL_PURP, &val);
+	if(Status == VI5300_ERROR_NONE && val == 0xaa)
+	{
+		Status = vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, cg_buf, 5);
+		if(Status != VI5300_ERROR_NONE)
+		{
+			vi5300_errmsg("Get XTALK parameter Failed Status = %d\n", Status);
+			Status = VI5300_ERROR_XTALK_CALIB;
+			goto err_exit;
+		}
+		dev->XtalkData.xtalk_cal = *((int8_t *)(cg_buf + 0));
+		dev->XtalkData.xtalk_peak = *((uint16_t *)(cg_buf + 1));
+		dev->XtalkData.xtalk_maxratio = *((uint8_t *)(cg_buf + 3));
+	} else {
+		vi5300_errmsg("XTALK Calibration Failed Status = %d, val = 0x%02x\n", Status, val);
+		Status = VI5300_ERROR_XTALK_CALIB;
+		goto err_exit;
+	}
+
+err_exit:
+	mdelay(2);
+	VI5300_Temperature_Enable(dev, 1);
+	return Status;
+}
+
+VI5300_Error VI5300_Config_XTalk_Parameter(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("CPU Abnormal Configing XTALK Failed Status = %d\n", Status);
+		return VI5300_ERROR_XTALK_CONFIG;
+	}
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x01, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x02, 0x00);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x03, *((uint8_t *)(&dev->XtalkConfig.xtalk_config)));
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x01, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x02, 0x1A);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0x03, dev->XtalkConfig.maxratio);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+
+	return Status;
+}
+
+VI5300_Error VI5300_Config_RefTof_Parameter(VI5300_DEV dev)
+{
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	union reftof_data {
+		int16_t reftof;
+		uint8_t buf[2];
+	} reftofdata;
+
+	Status = VI5300_Wait_For_CPU_Ready(dev);
+	if(Status != VI5300_ERROR_NONE)
+	{
+		vi5300_errmsg("CPU Abnormal Configing RefTof Failed Status = %d\n", Status);
+		return VI5300_ERROR_REFTOF_CONFIG;
+	}
+
+	reftofdata.reftof = dev->reftof_config;
+	if(reftofdata.reftof <= 0)
+	{
+		VI5300_Read_OTP(dev, 0x07, 2, reftofdata.buf);
+		vi5300_errmsg("reftof: %d\n", reftofdata.reftof);
+		reftofdata.reftof -= 30;
+	}
+
+	VI5300_Waiting_For_RCO_Stable(dev);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x01);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 1, 0x02);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 2, 0x17);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 3, reftofdata.buf[1]);
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 4, reftofdata.buf[0]);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+
+	return Status;
+}
+
+void VI5300_Read_ChipID(VI5300_DEV dev, uint8_t *chipid)
+{
+	VI5300_Read_OTP(dev, 0x25, 5, chipid);
+}
+
+void VI5300_Read_FW_Version(VI5300_DEV dev)
+{
+	uint8_t fw_version[4];
+
+	vi5300_write_reg_offset(dev, VI5300_REG_SCRATCH_PAD_BASE, 0, 0x06);
+	vi5300_write_byte(dev, VI5300_REG_CMD, VI5300_USER_CFG_CMD);
+	mdelay(5);
+	vi5300_read_multibytes(dev, VI5300_REG_SCRATCH_PAD_BASE, fw_version, 4);
+
+	vi5300_infomsg("fw version: %#x %#x %#x %#x\n", fw_version[0], fw_version[1], fw_version[2], fw_version[3]);
+}
diff --git a/drivers/misc/vi5300/vi5300_api.h b/drivers/misc/vi5300/vi5300_api.h
new file mode 100644
index 000000000000..fedde8ef0b06
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_api.h
@@ -0,0 +1,40 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef _VI5300_API_H_
+#define _VI5300_API_H_
+#include "vi5300.h"
+
+VI5300_Error VI5300_Chip_PowerON(VI5300_DEV dev);
+VI5300_Error VI5300_Chip_PowerOFF(VI5300_DEV dev);
+void VI5300_Read_ChipVersion(VI5300_DEV dev);
+void VI5300_Chip_Register_Init(VI5300_DEV dev);
+void VI5300_Set_Period(VI5300_DEV dev, uint32_t period);
+VI5300_Error VI5300_Single_Measure(VI5300_DEV dev);
+VI5300_Error VI5300_Start_Continuous_Measure(VI5300_DEV dev);
+VI5300_Error VI5300_Stop_Continuous_Measure(VI5300_DEV dev);
+VI5300_Error VI5300_Get_Measure_Data(VI5300_DEV dev);
+VI5300_Error VI5300_Get_Interrupt_State(VI5300_DEV dev);
+VI5300_Error VI5300_Chip_Init(VI5300_DEV dev);
+VI5300_Error VI5300_Start_XTalk_Calibration(VI5300_DEV dev);
+VI5300_Error VI5300_Start_Offset_Calibration(VI5300_DEV dev);
+VI5300_Error VI5300_Get_XTalk_Parameter(VI5300_DEV dev);
+VI5300_Error VI5300_Config_XTalk_Parameter(VI5300_DEV dev);
+VI5300_Error VI5300_Config_RefTof_Parameter(VI5300_DEV dev);
+void VI5300_Read_ChipID(VI5300_DEV dev, uint8_t *chipid);
+void VI5300_Read_FW_Version(VI5300_DEV dev);
+
+#endif
+
diff --git a/drivers/misc/vi5300/vi5300_def.h b/drivers/misc/vi5300/vi5300_def.h
new file mode 100644
index 000000000000..683c96125497
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_def.h
@@ -0,0 +1,37 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+ 
+#ifndef VI5300_DEF_H
+#define VI5300_DEF_H
+
+#include "vi5300.h"
+#include <linux/types.h>
+
+typedef unsigned int uint32_t;
+typedef int int32_t;
+
+typedef unsigned short uint16_t;
+typedef short int16_t;
+
+typedef unsigned char uint8_t;
+typedef signed char int8_t;
+
+typedef int32_t VI5300_Error;
+typedef struct vi5300_data* VI5300_DEV;
+
+#endif
+
diff --git a/drivers/misc/vi5300/vi5300_firmware.c b/drivers/misc/vi5300/vi5300_firmware.c
new file mode 100644
index 000000000000..a9ad46f05f15
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_firmware.c
@@ -0,0 +1,48 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/firmware.h>
+
+#include "vi5300_firmware.h"
+
+uint8_t Firmware[FIRMWARE_NUM];
+
+uint32_t LoadFirmware(VI5300_DEV dev)
+{
+	const struct firmware *vi5300_firmware;
+	const char *fw_name = NULL;
+	uint32_t data_size;
+	int err;
+
+	fw_name = "VI5300-M31_G01_R03_V5.28.bin";
+
+	err = request_firmware(&vi5300_firmware, fw_name, dev->dev);
+	if (err == 0 && vi5300_firmware) {
+		vi5300_infomsg("Firmware request succeeded for VI5300!\n");
+	} else {
+		vi5300_errmsg("Firmware request failed for VI5300! Code: %d\n", err);
+	}
+	
+	data_size = (uint32_t)vi5300_firmware->size;
+	vi5300_dbgmsg("vi5300_firmware size:%d\n", data_size);
+
+	memcpy(Firmware, vi5300_firmware->data, vi5300_firmware->size);
+	release_firmware(vi5300_firmware);
+	return data_size;
+}
diff --git a/drivers/misc/vi5300/vi5300_firmware.h b/drivers/misc/vi5300/vi5300_firmware.h
new file mode 100644
index 000000000000..b21eed59170d
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_firmware.h
@@ -0,0 +1,25 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef VI5300_FIRMWARE_H
+#define VI5300_FIRMWARE_H
+
+#include "vi5300.h"
+#define FIRMWARE_NUM 8192
+extern uint8_t Firmware[FIRMWARE_NUM];
+uint32_t LoadFirmware(VI5300_DEV dev);
+
+#endif
+
diff --git a/drivers/misc/vi5300/vi5300_module.c b/drivers/misc/vi5300/vi5300_module.c
new file mode 100644
index 000000000000..d2ef2fbf0b26
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_module.c
@@ -0,0 +1,1328 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/atomic.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <../drivers/gpio/gpiolib.h>
+#include <linux/miscdevice.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/of_gpio.h>
+#include <linux/kobject.h>
+#include <linux/kthread.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+
+#include "vi5300.h"
+#include "vi5300_platform.h"
+#include "vi5300_firmware.h"
+#include "vi5300_api.h"
+
+#define VI5300_IOCTL_PERIOD _IOW('p', 0x01, uint32_t)
+#define VI5300_IOCTL_XTALK_CALIB _IOR('p', 0x02, struct VI5300_XTALK_Calib_Data)
+#define VI5300_IOCTL_XTALK_CONFIG _IOW('p', 0x03, struct VI5300_XTALK_Config_Data)
+#define VI5300_IOCTL_OFFSET_CALIB _IOR('p', 0x04, struct VI5300_OFFSET_Calib_Data)
+#define VI5300_IOCTL_OFFSET_CONFIG _IOW('p', 0x05, int16_t)
+#define VI5300_IOCTL_REFTOF_CONFIG _IOW('p', 0x0c, int16_t)
+#define VI5300_IOCTL_POWER_ON _IO('p', 0x06)
+#define VI5300_IOCTL_CHIP_INIT _IO('p', 0x07)
+#define VI5300_IOCTL_START _IO('p', 0x08)
+#define VI5300_IOCTL_STOP _IO('p', 0x09)
+#define VI5300_IOCTL_MZ_DATA _IOR('p', 0x0a, struct VI5300_Measurement_Data)
+#define VI5300_IOCTL_POWER_OFF _IO('p', 0x0b)
+
+#define VI5300_DRV_NAME "vi5300"
+static int xtalk_mark;
+static int offset_mark;
+
+struct vi5300_api_fn_t {
+	int32_t (*Power_ON)(VI5300_DEV dev);
+	int32_t (*Power_OFF)(VI5300_DEV dev);
+	void (*Chip_Register_Init)(VI5300_DEV dev);
+	void (*Set_Period)(VI5300_DEV dev, uint32_t period);
+	int32_t (*Single_Measure)(VI5300_DEV dev);
+	int32_t (*Start_Continuous_Measure)(VI5300_DEV dev);
+	int32_t (*Stop_Continuous_Measure)(VI5300_DEV dev);
+	int32_t (*Get_Measure_Data)(VI5300_DEV dev);
+	int32_t (*Get_Interrupt_State)(VI5300_DEV dev);
+	int32_t (*Chip_Init)(VI5300_DEV dev);
+	int32_t (*Start_XTalk_Calibration)(VI5300_DEV dev);
+	int32_t (*Start_Offset_Calibration)(VI5300_DEV dev);
+	int32_t (*Get_XTalk_Parameter)(VI5300_DEV dev);
+	int32_t (*Config_XTalk_Parameter)(VI5300_DEV dev);
+	int32_t (*Config_RefTof_Parameter)(VI5300_DEV dev);
+	void (*Read_ChipID)(VI5300_DEV dev, uint8_t *chipid);
+};
+static struct vi5300_api_fn_t vi5300_api_func_tbl = {
+	.Power_ON = VI5300_Chip_PowerON,
+	.Power_OFF = VI5300_Chip_PowerOFF,
+	.Chip_Register_Init = VI5300_Chip_Register_Init,
+	.Set_Period = VI5300_Set_Period,
+	.Single_Measure = VI5300_Single_Measure,
+	.Start_Continuous_Measure = VI5300_Start_Continuous_Measure,
+	.Stop_Continuous_Measure = VI5300_Stop_Continuous_Measure,
+	.Get_Measure_Data = VI5300_Get_Measure_Data,
+	.Get_Interrupt_State = VI5300_Get_Interrupt_State,
+	.Chip_Init = VI5300_Chip_Init,
+	.Start_XTalk_Calibration = VI5300_Start_XTalk_Calibration,
+	.Start_Offset_Calibration = VI5300_Start_Offset_Calibration,
+	.Get_XTalk_Parameter = VI5300_Get_XTalk_Parameter,
+	.Config_XTalk_Parameter = VI5300_Config_XTalk_Parameter,
+	.Config_RefTof_Parameter = VI5300_Config_RefTof_Parameter,
+	.Read_ChipID = VI5300_Read_ChipID,
+};
+struct vi5300_api_fn_t *vi5300_func_tbl;
+
+static void vi5300_setupAPIFunctions(void)
+{
+	vi5300_func_tbl->Power_ON = VI5300_Chip_PowerON;
+	vi5300_func_tbl->Power_OFF = VI5300_Chip_PowerOFF;
+	vi5300_func_tbl->Chip_Register_Init = VI5300_Chip_Register_Init;
+	vi5300_func_tbl->Set_Period = VI5300_Set_Period;
+	vi5300_func_tbl->Single_Measure = VI5300_Single_Measure;
+	vi5300_func_tbl->Start_Continuous_Measure = VI5300_Start_Continuous_Measure;
+	vi5300_func_tbl->Stop_Continuous_Measure = VI5300_Stop_Continuous_Measure;
+	vi5300_func_tbl->Get_Measure_Data = VI5300_Get_Measure_Data;
+	vi5300_func_tbl->Get_Interrupt_State = VI5300_Get_Interrupt_State;
+	vi5300_func_tbl->Chip_Init = VI5300_Chip_Init;
+	vi5300_func_tbl->Start_XTalk_Calibration = VI5300_Start_XTalk_Calibration;
+	vi5300_func_tbl->Start_Offset_Calibration = VI5300_Start_Offset_Calibration;
+	vi5300_func_tbl->Get_XTalk_Parameter = VI5300_Get_XTalk_Parameter;
+	vi5300_func_tbl->Config_XTalk_Parameter = VI5300_Config_XTalk_Parameter;
+	vi5300_func_tbl->Config_RefTof_Parameter = VI5300_Config_RefTof_Parameter;
+	vi5300_func_tbl->Read_ChipID = VI5300_Read_ChipID;
+}
+
+static void vi5300_enable_irq(struct  vi5300_data *data)
+{
+	if(!data)
+		return;
+
+	if(data->intr_state == VI5300_INTR_DISABLED)
+	{
+		data->intr_state = VI5300_INTR_ENABLED;
+		enable_irq(data->irq);
+	}
+}
+
+static void vi5300_disable_irq(struct  vi5300_data *data)
+{
+	if(!data)
+		return;
+
+	if(data->intr_state == VI5300_INTR_ENABLED)
+	{
+		data->intr_state = VI5300_INTR_DISABLED;
+		disable_irq(data->irq);
+	}
+}
+
+static ssize_t vi5300_chip_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(NULL != data)
+		return scnprintf(buf, PAGE_SIZE, "%u\n", data->chip_enable);
+
+	return -EINVAL;
+}
+
+static ssize_t vi5300_chip_enable_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	unsigned int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		if(val !=0 && val !=1)
+		{
+			vi5300_errmsg("enable store unvalid value=%u\n", val);
+			mutex_unlock(&data->work_mutex);
+			return count;
+		}
+		if(val == 1)
+		{
+			if(data->chip_enable == 0)
+			{
+				data->chip_enable = 1;
+				vi5300_enable_irq(data);
+				Status = vi5300_func_tbl->Power_ON(data);
+				ktime_get_real_ts64(&data->start_ts);
+			} else {
+				vi5300_errmsg("already enabled!!\n");
+			}
+		} else {
+			if(data->chip_enable == 1)
+			{
+				data->chip_enable = 0;
+				vi5300_disable_irq(data);
+				data->fwdl_status = 0;
+				Status = vi5300_func_tbl->Power_OFF(data);
+			}
+			else {
+				vi5300_errmsg("already disabled!!\n");
+			}
+		}
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM;
+}
+
+static DEVICE_ATTR(chip_enable, 0664, vi5300_chip_enable_show, vi5300_chip_enable_store);
+
+/* for debug */
+static ssize_t vi5300_enable_debug_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(NULL != data)
+		return snprintf(buf, PAGE_SIZE, "%u\n", data->enable_debug);
+
+	return -EINVAL;
+}
+
+static ssize_t vi5300_enable_debug_store(struct device *dev,
+					struct device_attribute *attr, const
+					char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	unsigned int on = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &on) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		if ((on != 0) &&  (on != 1)) {
+			vi5300_errmsg("set debug=%d\n", on);
+			mutex_unlock(&data->work_mutex);
+			return count;
+		}
+		mutex_unlock(&data->work_mutex);
+		data->enable_debug = on;
+		return count;
+	}
+
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(enable_debug, 0664, vi5300_enable_debug_show, vi5300_enable_debug_store);
+
+static ssize_t vi5300_chip_init_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	unsigned int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		
+		if(val)
+		{
+			Status = vi5300_func_tbl->Chip_Init(data);
+			data->fwdl_status = 1;
+		} else {
+			mutex_unlock(&data->work_mutex);
+			return -EINVAL;
+		}
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM; 
+}
+
+static DEVICE_ATTR(chip_init, 0220, NULL, vi5300_chip_init_store);
+
+static ssize_t vi5300_period_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(data != NULL)
+		return scnprintf(buf, PAGE_SIZE, "%u\n", data->period);
+
+	return -EINVAL;
+}
+
+static ssize_t vi5300_period_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t val = 0;
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(data != NULL)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -EINVAL;
+		}
+
+		data->period = val;
+		vi5300_func_tbl->Set_Period(data, data->period);
+		mutex_unlock(&data->work_mutex);
+		return count;
+	}
+
+	return -EPERM;
+}
+
+static DEVICE_ATTR(period, 0664, vi5300_period_show, vi5300_period_store);
+
+static ssize_t vi5300_capture_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	unsigned int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		if(val !=0 && val !=1)
+		{
+			vi5300_errmsg("capture store unvalid value=%u\n", val);
+			mutex_unlock(&data->work_mutex);
+			return count;
+		}
+		if(val == 1)
+		{
+			Status = vi5300_func_tbl->Start_Continuous_Measure(data);
+		} else {
+			Status = vi5300_func_tbl->Stop_Continuous_Measure(data);
+		}
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM; 
+}
+
+static DEVICE_ATTR(capture, 0220, NULL, vi5300_capture_store);
+
+static ssize_t vi5300_xtalk_calib_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(data != NULL)
+		return scnprintf(buf, PAGE_SIZE, "%d %u %u\n", data->XtalkData.xtalk_cal,
+						data->XtalkData.xtalk_peak, data->XtalkData.xtalk_maxratio);
+
+	return -EPERM;
+}
+
+static ssize_t vi5300_xtalk_calib_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	unsigned int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		if(val !=1)
+		{
+			vi5300_errmsg("xtalk calibration store unvalid value=%u\n", val);
+			mutex_unlock(&data->work_mutex);
+			return count;
+		}
+		xtalk_mark = 1;
+		Status = vi5300_func_tbl->Start_XTalk_Calibration(data);
+		mdelay(600);
+		xtalk_mark = 0;
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM; 
+}
+
+static DEVICE_ATTR(xtalk_calib, 0664, vi5300_xtalk_calib_show, vi5300_xtalk_calib_store);
+
+static ssize_t vi5300_offset_calib_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+
+	if(data != NULL)
+		return scnprintf(buf, PAGE_SIZE, "%d\n", data->OffsetData.offset_cal);
+
+	return -EPERM;
+}
+
+static ssize_t vi5300_offset_calib_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	unsigned int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%u\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		if(val !=1)
+		{
+			vi5300_errmsg("offset calibration store unvalid value=%u\n", val);
+			mutex_unlock(&data->work_mutex);
+			return count;
+		}
+		offset_mark = 1;
+		Status = vi5300_func_tbl->Start_Offset_Calibration(data);
+		offset_mark = 0;
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM; 
+}
+
+static DEVICE_ATTR(offset_calib, 0664, vi5300_offset_calib_show, vi5300_offset_calib_store);
+
+static ssize_t vi5300_xtalk_config_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	VI5300_Error Status = VI5300_ERROR_NONE;
+	struct VI5300_XTALK_Config_Data *xtalk_data =
+			(struct VI5300_XTALK_Config_Data *)buf;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		data->XtalkConfig.xtalk_config = xtalk_data->xtalk_config;
+		data->XtalkConfig.maxratio = xtalk_data->maxratio;
+		Status = vi5300_func_tbl->Config_XTalk_Parameter(data);
+		mutex_unlock(&data->work_mutex);
+		return Status ? -1 : count;
+	}
+
+	return -EPERM; 
+}
+
+static DEVICE_ATTR(xtalk_config, 0220, NULL, vi5300_xtalk_config_store);
+
+static ssize_t vi5300_offset_config_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%x\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		data->offset_config = (int16_t)val;
+		mutex_unlock(&data->work_mutex);
+		return count;
+	}
+
+	return -EPERM;
+}
+
+static DEVICE_ATTR(offset_config, 0220, NULL, vi5300_offset_config_store);
+
+static ssize_t vi5300_reftof_config_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	int val = 0;
+
+	if(NULL != data)
+	{
+		mutex_lock(&data->work_mutex);
+		if(sscanf(buf, "%x\n", &val) != 1)
+		{
+			mutex_unlock(&data->work_mutex);
+			return -1;
+		}
+		data->reftof_config = (int16_t)val;
+		mutex_unlock(&data->work_mutex);
+		return count;
+	}
+
+	return -EPERM;
+}
+
+static DEVICE_ATTR(reftof_config, 0220, NULL, vi5300_reftof_config_store);
+
+static ssize_t vi5300_xtalk_data_read(struct file *filp,
+	struct kobject *kobj, struct bin_attribute *attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	void *src = (void *) &(data->XtalkData);
+	int rc = 0;
+
+	mutex_lock(&data->work_mutex);
+	if (!data->chip_enable) {
+		vi5300_errmsg("can't set calib data while disable sensor\n");
+		mutex_unlock(&data->work_mutex);
+		return -EBUSY;
+	}
+
+	if (count > sizeof(struct VI5300_XTALK_Calib_Data))
+		count = sizeof(struct VI5300_XTALK_Calib_Data);
+
+	memcpy(buf, src, count);
+	data->XtalkConfig.xtalk_config = data->XtalkData.xtalk_cal;
+	data->XtalkConfig.maxratio = data->XtalkData.xtalk_maxratio;
+	rc = vi5300_func_tbl->Config_XTalk_Parameter(data);
+	if (rc) {
+		vi5300_errmsg("config xtalk calibration data fail %d", rc);
+		mutex_unlock(&data->work_mutex);
+		return rc;
+	}
+	mutex_unlock(&data->work_mutex);
+
+	return count;
+}
+
+static ssize_t vi5300_xtalk_data_write(struct file *filp,
+	struct kobject *kobj, struct bin_attribute *attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	struct VI5300_XTALK_Calib_Data *xtalk_data =
+				(struct VI5300_XTALK_Calib_Data *)buf;
+	int rc = 0;
+
+	mutex_lock(&data->work_mutex);
+
+	if (!data->chip_enable) {
+		rc = -EBUSY;
+		vi5300_errmsg("can't set calib data while disable sensor\n");
+		goto error;
+	}
+
+	if (count != sizeof(struct VI5300_XTALK_Calib_Data))
+		goto invalid;
+
+	if(data->enable_debug) {
+		vi5300_errmsg("xtalk config: %d\n", xtalk_data->xtalk_cal);
+		vi5300_errmsg("xtalk maxratio: %d\n", xtalk_data->xtalk_maxratio);
+	}
+
+	data->XtalkConfig.xtalk_config = xtalk_data->xtalk_cal;
+	data->XtalkConfig.maxratio = xtalk_data->xtalk_maxratio;
+	rc = vi5300_func_tbl->Config_XTalk_Parameter(data);
+	if (rc) {
+		vi5300_errmsg("config xtalk calibration data fail %d", rc);
+		goto error;
+	}
+	mutex_unlock(&data->work_mutex);
+
+	return count;
+
+invalid:
+	vi5300_errmsg("invalid syntax");
+	rc = -EINVAL;
+	goto error;
+
+error:
+	mutex_unlock(&data->work_mutex);
+
+	return rc;
+}
+
+static ssize_t vi5300_offset_data_read(struct file *filp,
+	struct kobject *kobj, struct bin_attribute *attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	void *src = (void *) &(data->OffsetData);
+
+	mutex_lock(&data->work_mutex);
+	if (!data->chip_enable) {
+		vi5300_errmsg("can't set calib data while disable sensor\n");
+		mutex_unlock(&data->work_mutex);
+		return -EBUSY;
+	}
+
+	if (count > sizeof(struct VI5300_OFFSET_Calib_Data))
+		count = sizeof(struct VI5300_OFFSET_Calib_Data);
+
+	memcpy(buf, src, count);
+	data->offset_config = data->OffsetData.offset_cal;
+	mutex_unlock(&data->work_mutex);
+
+	return count;
+}
+
+static ssize_t vi5300_offset_data_write(struct file *filp,
+	struct kobject *kobj, struct bin_attribute *attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	struct VI5300_OFFSET_Calib_Data *offset_data = 
+				(struct VI5300_OFFSET_Calib_Data *)buf;
+	int rc = 0;
+
+	mutex_lock(&data->work_mutex);
+	if (!data->chip_enable) {
+		rc = -EBUSY;
+		vi5300_errmsg("can't set calib data while disable sensor\n");
+		goto error;
+	}
+
+	if (count != sizeof(struct VI5300_OFFSET_Calib_Data))
+		goto invalid;
+
+	if(data->enable_debug)
+		vi5300_errmsg("offset config: %d\n", offset_data->offset_cal);
+
+	data->offset_config = offset_data->offset_cal;
+	mutex_unlock(&data->work_mutex);
+	return count;
+
+invalid:
+	vi5300_errmsg("invalid syntax");
+	rc = -EINVAL;
+	goto error;
+
+error:
+	mutex_unlock(&data->work_mutex);
+	return rc;
+}
+
+static ssize_t vi5300_reftof_data_write(struct file *filp,
+	struct kobject *kobj, struct bin_attribute *attr,
+	char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct vi5300_data *data = dev_get_drvdata(dev);
+	struct VI5300_OFFSET_Calib_Data *offset_data = 
+				(struct VI5300_OFFSET_Calib_Data *)buf;
+	int rc = 0;
+
+	mutex_lock(&data->work_mutex);
+	if (!data->chip_enable) {
+		rc = -EBUSY;
+		vi5300_errmsg("can't set calib data while disable sensor\n");
+		goto error;
+	}
+
+	if (count != sizeof(struct VI5300_OFFSET_Calib_Data))
+		goto invalid;
+
+	if(data->enable_debug)
+		vi5300_errmsg("reftof config: %d\n", offset_data->ref_tof);
+
+	data->reftof_config = offset_data->ref_tof;
+	rc = vi5300_func_tbl->Config_RefTof_Parameter(data);
+	if (rc) {
+		vi5300_errmsg("config reftof calibration data fail %d", rc);
+		goto error;
+	}
+	mutex_unlock(&data->work_mutex);
+	return count;
+
+invalid:
+	vi5300_errmsg("invalid syntax");
+	rc = -EINVAL;
+	goto error;
+
+error:
+	mutex_unlock(&data->work_mutex);
+	return rc;
+}
+
+static struct attribute *vi5300_attributes[] = {
+	&dev_attr_chip_enable.attr,
+	&dev_attr_enable_debug.attr,
+	&dev_attr_chip_init.attr,
+	&dev_attr_period.attr,
+	&dev_attr_capture.attr,
+	&dev_attr_xtalk_calib.attr,
+	&dev_attr_offset_calib.attr,
+	&dev_attr_xtalk_config.attr,
+	&dev_attr_offset_config.attr,
+	&dev_attr_reftof_config.attr,
+	NULL,
+};
+
+static const struct attribute_group vi5300_attr_group = {
+	.name = NULL,
+	.attrs = vi5300_attributes,
+};
+
+static struct bin_attribute vi5300_xtalk_data_attr = {
+	.attr = {
+		.name = "xtalk_calib_data",
+		.mode = 0664/*S_IWUGO | S_IRUGO*/,
+	},
+	.size = sizeof(struct VI5300_XTALK_Calib_Data),
+	.read = vi5300_xtalk_data_read,
+	.write = vi5300_xtalk_data_write,
+};
+
+static struct bin_attribute vi5300_offset_data_attr = {
+	.attr = {
+		.name = "offset_calib_data",
+		.mode = 0664/*S_IWUGO | S_IRUGO*/,
+	},
+	.size = sizeof(struct VI5300_OFFSET_Calib_Data),
+	.read = vi5300_offset_data_read,
+	.write = vi5300_offset_data_write,
+};
+
+static struct bin_attribute vi5300_reftof_data_attr = {
+	.attr = {
+		.name = "reftof_calib_data",
+		.mode = 0222/*S_IWUGO*/,
+	},
+	.size = sizeof(struct VI5300_OFFSET_Calib_Data),
+	.write = vi5300_reftof_data_write,
+};
+
+static irqreturn_t vi5300_irq_handler(int vec, void *info)
+{
+	struct vi5300_data *data = (struct vi5300_data *)info;
+	VI5300_Error Status = VI5300_ERROR_NONE;
+
+	if(!data || !data->fwdl_status)
+		return IRQ_HANDLED;
+
+	if (data->irq == vec)
+	{
+		if(xtalk_mark)
+		{
+			Status = vi5300_func_tbl->Get_XTalk_Parameter(data);
+			if(Status != VI5300_ERROR_NONE)
+				vi5300_errmsg("%d : Status = %d\n" , __LINE__, Status);
+		}
+
+		if(!xtalk_mark && !offset_mark)
+		{
+			Status = vi5300_func_tbl->Get_Measure_Data(data);
+			if(Status != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d : Status = %d\n" , __LINE__, Status);
+				return IRQ_HANDLED;
+			}
+			input_report_abs(data->input_dev, ABS_HAT0Y, data->Rangedata.timeUSec);
+			input_report_abs(data->input_dev, ABS_HAT1X, data->Rangedata.RangeTof);
+			input_report_abs(data->input_dev, ABS_HAT1Y, data->Rangedata.RangeNoise);
+			input_report_abs(data->input_dev, ABS_BRAKE, data->Rangedata.RangePeak);
+			input_report_abs(data->input_dev, ABS_TILT_X, data->Rangedata.RangeConfidence);
+			input_report_abs(data->input_dev, ABS_WHEEL, data->Rangedata.RangeStatus);
+			input_report_abs(data->input_dev, ABS_TILT_Y, data->Rangedata.RangeCGcount);
+			input_report_abs(data->input_dev, ABS_HAT3X, data->Rangedata.RangeIntegralTimes);
+			input_sync(data->input_dev);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int vi5300_open(struct inode *inode, struct file *file)
+{
+	vi5300_errmsg("open!\n");
+	return 0;
+}
+
+static long vi5300_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long rc=0;
+	void __user *argp = (void __user *)arg;
+	struct vi5300_data *data = container_of(file->private_data,
+		struct vi5300_data, miscdev);
+
+	if(!data)
+		return -EFAULT;
+
+	switch (cmd) {
+		case VI5300_IOCTL_POWER_ON:
+			mutex_lock(&data->work_mutex);
+			vi5300_enable_irq(data);
+			rc = vi5300_func_tbl->Power_ON(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CHIP POWER ON FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EIO;
+			}
+			ktime_get_real_ts64(&data->start_ts);
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_CHIP_INIT:
+			mutex_lock(&data->work_mutex);
+			rc = vi5300_func_tbl->Chip_Init(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CHIP INIT FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EIO;
+			}
+			data->fwdl_status = 1;
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_PERIOD:
+			mutex_lock(&data->work_mutex);
+			if (copy_from_user(&(data->period), (uint32_t *)argp, sizeof(uint32_t)))
+			{
+				vi5300_errmsg("%d, GET PERIOD DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+			if(data->enable_debug)
+				vi5300_errmsg("period setting: %d\n", data->period);
+			vi5300_func_tbl->Set_Period(data, data->period);
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_XTALK_CALIB:
+			mutex_lock(&data->work_mutex);
+			xtalk_mark = 1;
+			rc = vi5300_func_tbl->Start_XTalk_Calibration(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, PERFORM XTALK CALIB FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EINVAL;
+			}
+			msleep(800);
+			if (copy_to_user(( struct VI5300_XTALK_Calib_Data *)argp, &(data->XtalkData),
+				sizeof( struct VI5300_XTALK_Calib_Data)))
+			{
+				vi5300_errmsg("%d, COPY XTALK CALIB DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+			xtalk_mark = 0;
+			data->XtalkConfig.xtalk_config = data->XtalkData.xtalk_cal;
+			data->XtalkConfig.maxratio = data->XtalkData.xtalk_maxratio;
+			rc = vi5300_func_tbl->Config_XTalk_Parameter(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, AFTER CALIBRATION,CONFIG XTALK PARAMETER FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EINVAL;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_XTALK_CONFIG:
+			mutex_lock(&data->work_mutex);
+			if (copy_from_user(&(data->XtalkConfig), (struct VI5300_XTALK_Config_Data *)argp, sizeof(struct VI5300_XTALK_Config_Data)))
+			{
+				vi5300_errmsg("%d, GET XTALK CALIB DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+
+			if(data->enable_debug)
+			{
+				vi5300_errmsg("xtalk config: %d\n", data->XtalkConfig.xtalk_config);
+				vi5300_errmsg("xtalk maxratio: %d\n", data->XtalkConfig.maxratio);
+			}
+
+			rc = vi5300_func_tbl->Config_XTalk_Parameter(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CONFIG XTALK PARAMETER FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EINVAL;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_OFFSET_CALIB:
+			mutex_lock(&data->work_mutex);
+			offset_mark = 1;
+			rc = vi5300_func_tbl->Start_Offset_Calibration(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, PERFORM OFFSET CALIB FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EINVAL;
+			}
+			if (copy_to_user(( struct VI5300_OFFSET_Calib_Data *)argp, &(data->OffsetData),
+				sizeof( struct VI5300_OFFSET_Calib_Data)))
+			{
+				vi5300_errmsg("%d, COPY OFFSET CALIB DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+			offset_mark = 0;
+			data->offset_config = data->OffsetData.offset_cal;
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_OFFSET_CONFIG:
+			mutex_lock(&data->work_mutex);
+			if (copy_from_user(&(data->offset_config), (int16_t *)argp, sizeof(int16_t)))
+			{
+				vi5300_errmsg("%d, GET OFFSET CALIB DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+
+			if(data->enable_debug)
+				vi5300_errmsg("offset config: %d\n", data->offset_config);
+
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_REFTOF_CONFIG:
+			mutex_lock(&data->work_mutex);
+			if (copy_from_user(&(data->reftof_config), (int16_t *)argp, sizeof(int16_t)))
+			{
+				vi5300_errmsg("%d, GET REFTOF CALIB DATA FAIL\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EINVAL;
+			}
+
+			if(data->enable_debug)
+				vi5300_errmsg("reftof config: %d\n", data->reftof_config);
+
+			rc = vi5300_func_tbl->Config_RefTof_Parameter(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CONFIG REFTOF DATA FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_START:
+			mutex_lock(&data->work_mutex);
+			rc = vi5300_func_tbl->Start_Continuous_Measure(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CHIP START RANGE FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EIO;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_MZ_DATA:
+			mutex_lock(&data->work_mutex);
+			if (copy_to_user((struct VI5300_Measurement_Data *)argp, &(data->Rangedata),
+				sizeof(struct VI5300_Measurement_Data)))
+			{
+				vi5300_errmsg("%d, COPY CONTINUOUS DATA FAIL\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EFAULT;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_STOP:
+			mutex_lock(&data->work_mutex);
+			rc = vi5300_func_tbl->Stop_Continuous_Measure(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CHIP STOP RANGE FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EIO;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		case VI5300_IOCTL_POWER_OFF:
+			mutex_lock(&data->work_mutex);
+			vi5300_disable_irq(data);
+			data->fwdl_status = 0;
+			rc = vi5300_func_tbl->Power_OFF(data);
+			if(rc != VI5300_ERROR_NONE)
+			{
+				vi5300_errmsg("%d, CHIP POWER OFF FAILED\n", __LINE__);
+				mutex_unlock(&data->work_mutex);
+				return -EIO;
+			}
+			mutex_unlock(&data->work_mutex);
+			break;
+		default:
+			rc = -EFAULT;
+	}
+
+	return rc;
+}
+
+static int vi5300_release(struct inode *inode, struct file *file)
+{
+	vi5300_errmsg("release!\n");
+	return 0;
+}
+
+static const struct file_operations vi5300_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = vi5300_ioctl,
+	.open = vi5300_open,
+	.release = vi5300_release,
+};
+
+static int vi5300_parse_dt(struct device_node *np, struct  vi5300_data *data)
+{
+	struct gpio_desc *irq_gpio_desc;
+	struct gpio_desc *xshut_gpio_desc;
+
+	if (!data || !np)
+		return -EINVAL;
+
+	
+	irq_gpio_desc = devm_gpiod_get_optional(data->dev, "irq", GPIOD_IN);
+	if (irq_gpio_desc == NULL) {
+		vi5300_errmsg("VI5300 Parse DT -> failed to get irq gpio, irq_gpio_desc is NULL\n");
+		return -ENODEV;
+	}
+	if (IS_ERR(irq_gpio_desc)) {
+		vi5300_errmsg("VI5300 Parse DT -> failed to get irq gpio: %lu\n", PTR_ERR(irq_gpio_desc));
+		return PTR_ERR(irq_gpio_desc);
+	}
+
+	data->irq_gpio = desc_to_gpio(irq_gpio_desc);
+	vi5300_infomsg("VI5300 Parse DT, Interrupt GPIO: %d\n", data->irq_gpio);
+
+	xshut_gpio_desc = devm_gpiod_get_optional(data->dev, "xshut", GPIOD_IN);
+	if (xshut_gpio_desc == NULL) {
+		vi5300_errmsg("VI5300 Parse DT -> failed to get xshut gpio, xshut_gpio_desc is NULL\n");
+		return -ENODEV;
+	}
+	if (IS_ERR(xshut_gpio_desc)) {
+		vi5300_errmsg("VI5300 Parse DT -> failed to get xshut gpio: %lu\n", PTR_ERR(xshut_gpio_desc));
+		return PTR_ERR(xshut_gpio_desc);
+	}
+
+	data->xshut_gpio = desc_to_gpio(xshut_gpio_desc);
+	vi5300_infomsg("VI5300 Parse DT, XSHUT GPIO: %d\n", data->xshut_gpio);
+
+	return  0;
+}
+
+static int vi5300_setup(struct  vi5300_data *data)
+{
+	int rc=0;
+	int irq = 0;
+	uint8_t buf = 0;
+
+	if (!data)
+		return -EINVAL;
+
+	if (!gpio_is_valid(data->irq_gpio) || !gpio_is_valid(data->xshut_gpio))
+		return -ENODEV;
+
+	gpio_request(data->xshut_gpio, "vi5300 xshut gpio");
+	gpio_request(data->irq_gpio, "vi5300 irq gpio");
+	gpio_direction_input(data->irq_gpio);
+	irq = gpio_to_irq(data->irq_gpio);
+	if(irq<0)
+	{
+		vi5300_errmsg("fail to map GPIO: %d to INT: %d\n", data->irq_gpio, irq);
+		rc = -EINVAL;
+		goto exit_free_gpio;
+	} else {
+		vi5300_dbgmsg("request irq: %d\n", irq);
+		rc = request_threaded_irq(irq,  NULL, vi5300_irq_handler,
+			IRQF_TRIGGER_FALLING |IRQF_ONESHOT, "vi5300_interrupt", (void *)data);
+		if (rc) {
+			vi5300_errmsg("%s(%d), Could not allocate VI5300_INT ! result:%d\n",__FUNCTION__, __LINE__, rc);
+			goto exit_free_irq;
+		}
+	}
+	data->irq = irq;
+	data->intr_state = VI5300_INTR_DISABLED;
+	disable_irq(data->irq);
+	data->fwdl_status = 0;
+	vi5300_func_tbl = &vi5300_api_func_tbl;
+	vi5300_setupAPIFunctions();
+	vi5300_func_tbl->Power_ON(data);
+	vi5300_func_tbl->Chip_Register_Init(data);
+	vi5300_read_byte(data, VI5300_REG_DEV_ADDR, &buf);
+	vi5300_func_tbl->Power_OFF(data);
+	if(buf != VI5300_CHIP_ADDR)
+	{
+		vi5300_errmsg("VI5300 I2C Transfer Failed, ChipAddr = 0x%x\n", buf);
+		rc = -EFAULT;
+		goto exit_free_irq;
+	}
+	vi5300_infomsg("VI5300 I2C Transfer Successfully, ChipAddr = 0x%x\n", buf);
+
+	data->input_dev = input_allocate_device();
+	if (data->input_dev == NULL) {
+		vi5300_errmsg("Error allocating input_dev.\n");
+		goto input_dev_alloc_err;
+	}
+	data->input_dev->name = "vi5300";
+	data->input_dev->id.bustype = BUS_I2C;
+	input_set_drvdata(data->input_dev, data);
+	set_bit(EV_ABS, data->input_dev->evbit);
+	input_set_abs_params(data->input_dev, ABS_HAT3X, 0, 0xffffffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_HAT0Y, 0, 0xffffffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_HAT1X, 0, 0xffffffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_HAT1Y, 0, 0xffffffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_BRAKE, 0, 0xffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_TILT_X, 0, 0xffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_WHEEL, 0, 0xffff, 0, 0);
+	input_set_abs_params(data->input_dev, ABS_TILT_Y, 0, 0xffff, 0, 0);
+	rc = input_register_device(data->input_dev);
+	if(rc) {
+		vi5300_errmsg("Error registering input_dev.\n");
+		goto input_reg_err;
+	}
+	rc = sysfs_create_group(&data->input_dev->dev.kobj, &vi5300_attr_group);
+	if (rc) {
+		vi5300_errmsg("Error creating sysfs attribute group.\n");
+		goto sysfs_create_group_err;
+	}
+	rc = sysfs_create_bin_file(&data->input_dev->dev.kobj, &vi5300_xtalk_data_attr);
+	if (rc) {
+		rc = -ENOMEM;
+		vi5300_errmsg("%d error:%d\n", __LINE__, rc);
+		goto sysfs_create_bin_err1;
+	}
+	rc = sysfs_create_bin_file(&data->input_dev->dev.kobj, &vi5300_offset_data_attr);
+	if (rc) {
+		rc = -ENOMEM;
+		vi5300_errmsg("%d error:%d\n", __LINE__, rc);
+		goto sysfs_create_bin_err2;
+	}
+	rc = sysfs_create_bin_file(&data->input_dev->dev.kobj, &vi5300_reftof_data_attr);
+	if (rc) {
+		rc = -ENOMEM;
+		vi5300_errmsg("%d error:%d\n", __LINE__, rc);
+		goto sysfs_create_bin_err3;
+	}
+
+	data->miscdev.minor = MISC_DYNAMIC_MINOR;
+	data->miscdev.name = "vi5300";
+	data->miscdev.fops = &vi5300_fops;
+	if (misc_register(&data->miscdev) != 0)
+	{
+		vi5300_errmsg("Could not register misc. dev for VI5300 Sensor\n");
+		rc = -ENOMEM;
+		goto misc_register_err;
+	}
+	data->period = 30;
+	data->XtalkConfig.xtalk_config = 0;
+	data->XtalkConfig.maxratio = 0;
+	data->offset_config = 0;
+	data->enable_debug = 0;
+	data->Rangedata.RangeStatus = 255;
+
+	return 0;
+
+misc_register_err:
+	sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+		&vi5300_reftof_data_attr);
+sysfs_create_bin_err3:
+	sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+		&vi5300_offset_data_attr);
+sysfs_create_bin_err2:
+	sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+		&vi5300_xtalk_data_attr);
+sysfs_create_bin_err1:
+	sysfs_remove_group(&data->input_dev->dev.kobj,
+		&vi5300_attr_group);
+sysfs_create_group_err:
+	input_unregister_device(data->input_dev);
+input_reg_err:
+	input_free_device(data->input_dev);
+input_dev_alloc_err:
+exit_free_irq:
+	free_irq(irq, data);
+exit_free_gpio:
+	gpio_free(data->xshut_gpio);
+	gpio_free(data->irq_gpio);
+	return rc;
+}
+
+static int vi5300_probe(struct i2c_client *client)
+{
+	struct vi5300_data *vi5300_data = NULL;
+	struct device *dev = &client->dev;
+	struct device_node *node;
+	int ret  = 0;
+
+	vi5300_infomsg("Try to probe VI5300 sensor!\n");
+	vi5300_data = kzalloc(sizeof(struct vi5300_data), GFP_KERNEL);
+	if(!vi5300_data)
+	{
+		vi5300_errmsg("devm_kzalloc error\n");
+		return -ENOMEM;
+	}
+	if (!dev->of_node)
+	{
+		vi5300_errmsg("VI5300 Error dev->of_node = NULL\n");
+		kfree(vi5300_data);
+		return -EINVAL;
+	}
+	/* setup device data */
+	vi5300_infomsg("VI5300 Try to setup!!!\n");
+	vi5300_data->dev_name = dev_name(&client->dev);
+	vi5300_data->client = client;
+	vi5300_data->dev = dev;
+	node = dev->of_node;
+	i2c_set_clientdata(client, vi5300_data);
+	mutex_init(&vi5300_data->work_mutex);
+	ret = vi5300_parse_dt(node, vi5300_data);
+	if(ret) {
+		vi5300_errmsg("VI5300 Parse DT Failed\n");
+		goto exit_error;
+	}
+	ret = vi5300_setup(vi5300_data);
+	if(ret) {
+		vi5300_errmsg("VI5300 Setup Failed\n");
+		goto exit_error;
+	}
+	vi5300_infomsg("Probe OK for dToF sensor VI5300!\n");
+	return 0;
+
+exit_error:
+	vi5300_errmsg("VI5300 Error label!!!\n");
+	mutex_destroy(&vi5300_data->work_mutex);
+	i2c_set_clientdata(client, NULL);
+	kfree(vi5300_data);
+	return ret;
+
+}
+
+static void vi5300_remove(struct i2c_client *client)
+{
+	struct vi5300_data *data = i2c_get_clientdata(client);
+
+	if(data->input_dev)
+	{
+		vi5300_dbgmsg("to unregister sysfs dev\n");
+		sysfs_remove_group(&data->input_dev->dev.kobj,
+			&vi5300_attr_group);
+		sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+			&vi5300_xtalk_data_attr);
+		sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+			&vi5300_offset_data_attr);
+		sysfs_remove_bin_file(&data->input_dev->dev.kobj,
+			&vi5300_reftof_data_attr);
+		vi5300_dbgmsg("to unregister input dev\n");
+		input_unregister_device(data->input_dev);
+	}
+	if (!IS_ERR(data->miscdev.this_device) &&
+			data->miscdev.this_device != NULL) {
+		vi5300_dbgmsg("to unregister misc dev\n");
+		misc_deregister(&data->miscdev);
+	}
+	if(data->xshut_gpio)
+	{
+		gpio_direction_output(data->xshut_gpio, 0);
+		gpio_free(data->xshut_gpio);
+	}
+	if(data->irq_gpio)
+	{
+		free_irq(data->irq, data);
+		gpio_free(data->irq_gpio);
+	}
+	i2c_set_clientdata(client, NULL);
+	mutex_destroy(&data->work_mutex);
+	kfree(data);
+	//return 0;
+}
+static const struct i2c_device_id vi5300_id[] = {
+	{ VI5300_DRV_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, vi5300_id);
+
+static const struct of_device_id vi5300_dt_match[] = {
+	{.compatible = "evisionics,vi5300",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vi5300_dt_match);
+
+struct i2c_driver vi5300_driver = {
+	.driver  = {
+		.name = VI5300_DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = vi5300_dt_match,
+	},
+	.probe = vi5300_probe,
+	.remove = vi5300_remove,
+	.id_table = vi5300_id,
+};
+
+static int __init vi5300_init(void)
+{
+	return i2c_add_driver(&vi5300_driver);
+}
+
+static void  __exit vi5300_exit(void)
+{
+	i2c_del_driver(&vi5300_driver);
+}
+
+module_init(vi5300_init);
+module_exit(vi5300_exit);
+
+MODULE_AUTHOR("William.li<william.li@vidar.ai>");
+MODULE_AUTHOR("Vasyl Dykyj");
+MODULE_DESCRIPTION("VI5300 FlightSense TOF  sensor Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/vi5300/vi5300_platform.c b/drivers/misc/vi5300/vi5300_platform.c
new file mode 100644
index 000000000000..c1cb66783403
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_platform.c
@@ -0,0 +1,113 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "vi5300_platform.h"
+#include "vi5300_def.h"
+
+static int32_t vi5300_i2c_write(VI5300_DEV dev, uint8_t reg, uint8_t *data, uint8_t len)
+{
+	int ret = 0;
+	uint8_t *addr_buf;
+	struct i2c_msg msg;
+	struct i2c_client *client = dev->client;
+
+	if(!client)
+		return -EINVAL;
+	addr_buf = kmalloc(len + 1, GFP_KERNEL);
+	if (!addr_buf)
+		return -ENOMEM;
+	addr_buf[0] = reg;
+	memcpy(&addr_buf[1], data, len);
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.buf = addr_buf;
+	msg.len = len+1;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if(ret != 1)
+	{
+		pr_err("%s: i2c_transfer err:%d, addr:0x%x, reg:0x%x\n",
+			__func__, ret, client->addr, reg);
+	}
+	kfree(addr_buf);
+	return ret < 0 ? ret : (ret != 1 ? -EIO : 0);
+}
+
+static int32_t vi5300_i2c_read(VI5300_DEV dev, uint8_t reg, uint8_t *data, uint8_t len)
+{
+	int ret =0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = dev->client;
+
+	if(!client)
+		return -EINVAL;
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].buf = &reg;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = len;
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if(ret != 2)
+	{
+		pr_err("%s: i2c_transfer err:%d, addr:0x%x, reg:0x%x\n",
+			__func__, ret, client->addr, reg);
+	}
+
+	return ret < 0 ? ret : (ret != 2 ? -EIO : 0);
+}
+
+int32_t vi5300_write_byte(VI5300_DEV dev, uint8_t reg, uint8_t data)
+{
+	return vi5300_i2c_write(dev, reg, &data, 1);
+}
+
+int32_t vi5300_read_byte(VI5300_DEV dev, uint8_t reg, uint8_t *data)
+{
+	return vi5300_i2c_read(dev, reg, data, 1);
+}
+
+int32_t vi5300_write_multibytes(VI5300_DEV dev, uint8_t reg, uint8_t *data, int32_t count)
+{
+	return vi5300_i2c_write(dev, reg, data, count);
+}
+
+int32_t vi5300_read_multibytes(VI5300_DEV dev, uint8_t reg, uint8_t *data, int32_t count)
+{
+	return vi5300_i2c_read(dev, reg, data, count);
+}
+
+int32_t vi5300_write_reg_offset(VI5300_DEV dev, uint8_t reg, uint8_t offset, uint8_t data)
+{
+	return vi5300_write_byte(dev, reg+offset, data);
+}
+
+int32_t vi5300_read_reg_offset(VI5300_DEV dev, uint8_t reg, uint8_t offset, uint8_t *data)
+{
+	return vi5300_read_byte(dev, reg+offset, data);
+}
+
diff --git a/drivers/misc/vi5300/vi5300_platform.h b/drivers/misc/vi5300/vi5300_platform.h
new file mode 100644
index 000000000000..cf056a9d2151
--- /dev/null
+++ b/drivers/misc/vi5300/vi5300_platform.h
@@ -0,0 +1,30 @@
+/*
+ *  vi5300_module.c - Linux kernel modules for VI5300 FlightSense TOF
+ *						 sensor
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *  Originally developed for Linux 4.x by vendor.
+ *  Ported to Raspberry Pi kernel 6.15.0 by Vasyl Dykyj.
+ */
+
+#ifndef VI5300_PLATFORM_H
+#define VI5300_PLATFORM_H
+
+#include "vi5300.h"
+
+int32_t vi5300_write_byte(VI5300_DEV dev, uint8_t reg, uint8_t data);
+int32_t vi5300_read_byte(VI5300_DEV dev, uint8_t reg, uint8_t *data);
+int32_t vi5300_write_multibytes(VI5300_DEV dev, uint8_t reg, uint8_t *data, int32_t count);
+int32_t vi5300_read_multibytes(VI5300_DEV dev, uint8_t reg, uint8_t *data, int32_t count);
+int32_t vi5300_write_reg_offset(VI5300_DEV dev, uint8_t reg, uint8_t offset, uint8_t data);
+int32_t vi5300_read_reg_offset(VI5300_DEV dev, uint8_t reg, uint8_t offset, uint8_t *data);
+
+ #endif
-- 
2.43.0

